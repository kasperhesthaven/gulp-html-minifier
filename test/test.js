const htmlminimizer = require("../index.js");
const assert = require("assert");
const path = require("path");
const fs = require("fs");
const Vinyl = require("vinyl");

describe("gulp-html-minimizer", () => {
  it("should return file when it isNull()", (done) => {
    const htmlMinimizer = htmlminimizer();
    const file = {
      isNull: () => true,
      _contents: " ",
    };
    htmlMinimizer.on("data", (data) => {
      assert.equal(data, file);
      done();
    });
    htmlMinimizer.write(file);
  });

  it("should return file when it is empty", (done) => {
    const htmlMinimizer = htmlminimizer();
    const file = {
      _contents: "",
    };
    htmlMinimizer.on("data", (data) => {
      assert.equal(data, file);
      done();
    });
    htmlMinimizer.write(file);
  });

  it("should emit error when file isStream()", (done) => {
    const htmlMinimizer = htmlminimizer();
    const file = {
      isNull: () => false,
      isBuffer: () => false,
      isStream: () => true,
      _contents: " ",
    };
    htmlMinimizer.on("error", (error) => {
      assert.equal(error.message, "Streaming is not supported.");
      done();
    });
    htmlMinimizer.write(file);
  });

  it("should minimize a valid HTML file with default options", (done) => {
    const htmlMinimizer = htmlminimizer();
    const htmlFile = new Vinyl({
      cwd: __dirname,
      base: path.join(__dirname, "test"),
      path: path.join(__dirname, "Original", "original.html"),
      contents: fs.readFileSync(
        path.join(__dirname, "Original", "original.html")
      ),
    });
    const expectedHtmlFile = fs.readFileSync(
      path.join(__dirname, "Expected", "default-expected.html"),
      "utf-8"
    );
    htmlMinimizer.on("data", (data) => {
      assert.equal(data.contents, expectedHtmlFile);
      done();
    });
    htmlMinimizer.write(htmlFile);
  });

  it("should minimize a valid HTML file with all switchable options enabled", (done) => {
    const htmlMinimizer = htmlminimizer({
      caseSensitive: true,
      collapseBooleanAttributes: true,
      collapseInlineTagWhitespace: true,
      collapseWhitespace: true,
      conservativeCollapse: true,
      decodeEntities: true,
      html5: true,
      includeAutoGeneratedTags: true,
      keepClosingSlash: true,
      minifyCSS: true,
      minifyJS: true,
      preserveLineBreaks: true,
      preventAttributesEscaping: true,
      processConditionalComments: true,
      removeAttributeQuotes: true,
      removeComments: true,
      removeEmptyAttributes: true,
      removeEmptyElements: true,
      removeOptionalTags: true,
      removeRedundantAttributes: true,
      removeScriptTypeAttributes: true,
      removeStyleLinkTypeAttributes: true,
      removeTagWhitespace: true,
      sortAttributes: true,
      sortClassName: true,
      trimCustomFragments: true,
      useShortDoctype: true,
    });
    const htmlFile = new Vinyl({
      cwd: __dirname,
      base: path.join(__dirname, "test"),
      path: path.join(__dirname, "Original", "original.html"),
      contents: fs.readFileSync(
        path.join(__dirname, "Original", "original.html")
      ),
    });
    const expectedHtmlFile = fs.readFileSync(
      path.join(__dirname, "Expected", "full-expected.html"),
      "utf-8"
    );
    htmlMinimizer.on("data", (data) => {
      assert.equal(data.contents, expectedHtmlFile);
      done();
    });
    htmlMinimizer.write(htmlFile);
  });

  it("should throw error on invalid HTML", (done) => {
    const htmlMinimizer = htmlminimizer();
    const htmlFile = {
      isNull: () => false,
      isBuffer: () => true,
      _contents: Buffer.from("<div//>invalid markup</div>"),
    };
    htmlMinimizer.on("error", (error) => {
      assert.equal(error.message, `Parse Error: <div//>invalid markup</div>`);
      done();
    });
    htmlMinimizer.write(htmlFile);
  });

  it("should skip without error on invalid HTML with skipInvalidFiles", (done) => {
    const htmlMinimizer = htmlminimizer({ skipInvalidFiles: true });
    const htmlFile = {
      isNull: () => false,
      isBuffer: () => true,
      _contents: Buffer.from("<div//>invalid markup</div>"),
      relative: "foo.html",
    };
    htmlMinimizer.write(htmlFile, (error) => {
      assert.equal(error, undefined);
      done();
    });
  });
});
